# Database ID Generation Strategy

## ID Types and Usage

### 1. UUIDv7 (Time-ordered UUID)

- **Used for**: `books` table only
- **Generated by**: `IdGenerator.uuidV7()`
- **Format**: Standard UUID format (36 chars with hyphens)
- **Example**: `0192f3d4-5678-7abc-def0-123456789abc`
- **PostgreSQL Type**: `uuid`

### 2. NanoID (URL-safe random IDs)

- **Used for**: All other tables
- **PostgreSQL Type**: `text`
- **Alphabet**: Base62 (0-9, a-z, A-Z)

#### NanoID Sizes by Table Volume

**10 chars (default)** - `IdGenerator.generate()`

- `book_external_ids` - Multiple providers per book
- `book_raw_data` - Raw JSON storage
- `book_image_links` - Multiple image types
- `book_identifiers` - Multiple identifier types
- `authors` - Thousands of unique authors
- `categories` - Hundreds of categories

`book_image_links` additionally carries mutation audit columns (`created_at`, `updated_at`, `s3_uploaded_at`) so cover-link provenance remains traceable over time.

**12 chars (high volume)** - `IdGenerator.generateLong()`

- `book_authors` - Many-to-many, very high volume
- `book_categories` - Many-to-many, high volume
- `book_lists_join` - Many-to-many for lists

**8 chars (low volume)** - `IdGenerator.generateShort()`

- `book_lists` - Limited number of lists
- `book_dimensions` - One per book max
- `book_contributing_sources` - Few sources per book

## Why This Strategy?

1. **UUIDv7 for books**: Time-ordered, globally unique, standard format
2. **NanoID for others**: Shorter, URL-safe, sufficient uniqueness
3. **Variable sizes**: Optimize storage while maintaining collision resistance

## Collision Probability

With Base62 alphabet:

- 8 chars: ~218 trillion possibilities (good for <1M records)
- 10 chars: ~839 quadrillion possibilities (good for <1B records)
- 12 chars: ~3.2 sextillion possibilities (essentially unlimited)
